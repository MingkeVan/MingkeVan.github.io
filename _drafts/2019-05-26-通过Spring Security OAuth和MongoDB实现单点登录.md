---
layout:      post
title:       单点登录实践
subtitle:    基于Spring Security OAuth和MongoDB
date:        2019-05-26
author:      Mingke Fan
header-img:  img/post-bg-e2e-ux.jpg
tags:
    - jekyll
---

 在写代码之前，我来首先解释一下为什么选择[Spring Security OAuth2.0](<https://projects.spring.io/spring-security-oauth/docs/oauth2.html>)和[MongoDB](https://www.mongodb.com/)来实现***单点登录***认证服务端。

显然，每种微服务架构都有几个共同工作的服务。而认证和授权服务和macro、fat -war 以及fat -jar并不一样。假设你有一个服务，它是由两个微服务组成的，那么为两个微服务单独配备认证和授权服务恐怕不太好。换而言之，我们不可能为所有的微服务单独进行认证和授权，必须将认证和授权服务抽出来，单独作为一个模块。

我们知道，必须有一个中心化的认证系统用于用户认证和授权，并且它的授权信息可以被所有微服务共用。

接下来简单说一下RESTful服务，无状态会话和有状态会话。为了访问服务端的内容，需要几个步骤呢？答案是三步：认证（用户信息）、授权（用户权限管理）和会话管理。

最好的方法是在用户认证通过后，给用户一个token用于后续请求。token是在用户之外单独管理的。为了保持token占用的存储尽可能小，需要删除过期token。这意味着最少只有一个token，最多有user size个token。理论上来说，Restful服务应该是无状态的。

**什么是无状态和有状态会话？**

**无状态会话**

*在计算中，无状态协议是一种把所有请求看作是与之前请求毫无关联的独立事务的通讯协议，这样通讯就由成对独立的请求和回复组成。无状态协议不需要服务端保留会话信息或者状态。作为对比，需要在服务端保存内部状态的协议被称作有状态协议。*

**有状态会话**

*与无状态会话的定义相反。*
但是实际上对于RESTful服务来说，使用完全无状态的会话管理是不可能的。

对于前端应用，曾经为了防止[CSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery)（跨站请求伪造）不在cookie中保存token。并且在移动时代，移动APP并不能有效的支持cookie。

对于后端应用，存储token则非常容易，可以通过MongoDB或者redis来存储。

接着来说前端，如果前端应用无法正常使用cookie，那我们把token存在哪里呢？

答案是：HTML5的localStorage和sessionStorage。

*“通过local storage，web应用可以将数据存在用户浏览器本地。在HTML5出现之前，应用数据不得不存储在cookie中，并且每次请求都要携带cookie。local storage更为安全，容量更为充足（至少5mb），并不会影响网站的性能。local storage与每个origin（域名和协议）关联。来自同一个origin的页面，可以存储和访问同样的数据。“*

sessionStorage和localStorage的不同之处在于sessionStorage只存储一个会话的数据。

尽管大多数浏览器不支持sessionStorage，你可以通过一些外部的js来使localStorage像sessionStorage一样工作，或者通过[polyfill](https://polyfill.io/v3/)在不支持该功能的浏览器中使用sessionStorage。

然后，你就可以从localStorage或者sessionStorage中取出token，并放在http headers中传输。

**什么是[OAuth2.0](https://tools.ietf.org/html/rfc6749)？**

*“OAuth2.0授权框架使得第三方应用获得http服务的有限权限。通过建立资源所有者和http服务之间的权限联系来代表资源所有者，或者允许第三方应用代表本人获得访问权。”*

幸运地是它支持自定义认证服务器可以访问的内容。在线调查表明Google，Facebook，Windows Live，GitHub，Slack，Dropbox等很多网站都在使用OAuth2.0。

**OAuth2.0概述**
*“OAuth2.0首先需要获得用户的授权。对于浏览器或者移动APP来说，通常会跳出一个授权页面。”*

OAuth2.0针对不同的用户案例提供多种“授权类型”。授权类型的定义是：

* 在web服务器上运行的应用程序的授权码
* 隐含于浏览器或者移动app
* 用于登录的密码
* 访问应用的凭据

基于这些授权类型，我们可以对用户进行认证和授权。

**为什么是[Spring Security OAuth2.0](http://projects.spring.io/spring-security-oauth/docs/oauth2.html)？**

Spring已经集成和支持LDAP，社交平台和数据库。

所以真正的问题应该是

**为什么不用[Spring Security OAuth2.0](http://projects.spring.io/spring-security-oauth/docs/oauth2.html)？**

**[Spring Security OAuth2.0](http://projects.spring.io/spring-security-oauth/docs/oauth2.html)相关issue**

Spring Security OAuth2.0支持在MySQL中存储token。但随着Spring支持丰富的NoSQL数据库，使用NoSQL可能是更好的解决方案。顺便提一下，Spring Security OAuth2.0也支持InMemoryTokenStore和JWT。

*“对单个服务器来说，默认的InMemoryTokenStore非常棒（即在发生故障时流量较低且无法与备份服务器热交换）”*

## reference

1、[Using Spring Security OAuth 2.0 and MongoDB to secure a Microservice/SOA System](<https://malike.github.io/Spring-Security-OAuth2.html>)














































































































































































































































































































































































































































































































































