---
layout:     post
title:      动态规划
subtitle:   算法导论学习笔记系列-1
date:       2018-05-19 
author:     Mingke Fan
header-img: img/post-bg-e2e-ux.jpg
tags:
    - 算法
    - 学习笔记
    - 剪贴法
---

# 算法导论学习笔记系列之一

## 动态规划（也被称作备忘法）

### 最大公共子串（LCS）

存在两个字符串A（长度为n）和B(长度为m) 找出他们的公共子串

#### 暴力搜索

  先找出A中所有的子串 再在B中搜索是否存在此子串

  给定子串，找出B中是否存在该子串的时间复杂度为O(n),因为只需要顺序遍历一次即可。

  B中总共含有2^m个子序列（可以将B看做为m位的位向量，每一位上可以为0或1，1代表包含该位，则共有2^m中可能组合。）

  worstcase: O(n*2^m) very slow

#### 简化即动态规划

  使用C[i,j]记录A[1...i]和B[1...j]的公共子串的长度。则C[n,m]即为A和B的最长公共子串的长度。

  C[i，j]的计算过程为
  $$
  C[i,j]=
  \begin{equation}
  \begin{cases}
  0, & 若i=0或j=0 \\
  c[i-1,j-1]+1, & 若i,j>0   且 x_i = y_i \\
   max(c[i,j-1],c[i-1,j]), & 若i,j>0且x_i \neq y_i
  \end{cases}
  \end{equation}
  $$
  上面公式我们通过条件限定了需要求解哪些子问题，与编辑距离类似。

  子问题空间为mn 因为最终拆分出的子问题为 1,1 1,2 1,3 ... m,1 m,2 ...m,n

  时间复杂度为θ（mn）

  空间复杂度为θ（mn），实际上只需要θ（min(m,n)）每次只用一行或一列，和上一行或上一列的若干数据，选择行或列 是基于哪个更短。

  用d[i]

 ##### 动态规划两种方法

  * top down

  * bottom up

    得到C[i,j]后通过回朔法得到LCS



剪贴法：cut and paste 用来证明如果最优解不是最优解 则通过剪贴可以找到更好的最优解 与假设矛盾 从而得证

最优子结构性质：

一个问题的最优解包含子问题的最优解

动态规划3 hallmark（特征）：

最优子结构；重叠子问题



相关问题：编辑距离问题
